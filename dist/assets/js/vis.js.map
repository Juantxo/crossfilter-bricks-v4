{"version":3,"names":[],"mappings":"","sources":["vis.js"],"sourcesContent":["// https://bl.ocks.org/micahstubbs/66db7c01723983ff028584b6f304a54a\n\n((window, d3) => {\n\n    // vars\n    let p1 = d3.json(\"./assets/data/bricks$.value.json?v=2000\");\n    let p2 = d3.json(\"./assets/data/activeIndicator$.value.json?v=2000\");\n    let p3 = d3.json(\"./assets/data/analyticsIndicators$.value.json?v=2000\");\n    let data = [];\n    let charts;\n    let chart;\n    let crossAll;\n    const formatNumber = d3.format(',d');\n\n    // functions\n\n    function barChart() {\n        if (!barChart.id) barChart.id = 0;\n\n        let margin = { top: 10, right: 13, bottom: 20, left: 10 };\n        let x;\n        let y = d3.scaleLinear().range([100, 0]);\n        const id = barChart.id++;\n        const axis = d3.axisBottom();\n        const brush = d3.brushX();\n        let brushDirty;\n        let dimension;\n        let group;\n        let round;\n        let gBrush;\n\n        function chart(div) {\n            const width = x.range()[1];\n            const height = y.range()[0];\n\n            brush.extent([[0, 0], [width, height]]);\n\n            y.domain([0, group.top(1)[0].value]);\n\n            div.each(function () {\n                const div = d3.select(this);\n                let g = div.select('g');\n\n                // Create the skeletal chart.\n                if (g.empty()) {\n                    div.select('.title').append('a')\n                        //.attr('href', `javascript:reset(${id})`)\n                        .attr(\"href\", \"#\")\n                        .attr('class', 'reset')\n                        .text('reset')\n                        .style('display', 'none')\n                        .on(\"click\", (d, i, arr) => {\n                            //let y = `${id}`;\n                            reset(`${id}`);\n\n                        });\n\n                    g = div.append('svg')\n                        .attr('width', width + margin.left + margin.right)\n                        .attr('height', height + margin.top + margin.bottom)\n                        .append('g')\n                        .attr('transform', `translate(${margin.left},${margin.top})`);\n\n                    g.append('clipPath')\n                        .attr('id', `clip-${id}`)\n                        .append('rect')\n                        .attr('width', width)\n                        .attr('height', height);\n\n                    g.selectAll('.bar')\n                        .data(['background', 'foreground'])\n                        .enter().append('path')\n                        .attr('class', d => `${d} bar`)\n                        .datum(group.all());\n\n                    g.selectAll('.foreground.bar')\n                        .attr('clip-path', `url(#clip-${id})`);\n\n                    g.append('g')\n                        .attr('class', 'axis')\n                        .attr('transform', `translate(0,${height})`)\n                        .call(axis);\n\n                    // Initialize the brush component with pretty resize handles.\n                    gBrush = g.append('g')\n                        .attr('class', 'brush')\n                        .call(brush);\n\n                    gBrush.selectAll('.handle--custom')\n                        .data([{ type: 'w' }, { type: 'e' }])\n                        .enter().append('path')\n                        .attr('class', 'brush-handle')\n                        .attr('cursor', 'ew-resize')\n                        .attr('d', resizePath)\n                        .style('display', 'none');\n                }\n\n                // Only redraw the brush if set externally.\n                if (brushDirty !== false) {\n                    const filterVal = brushDirty;\n                    brushDirty = false;\n\n                    div.select('.title a').style('display', d3.brushSelection(div) ? null : 'none');\n\n                    if (!filterVal) {\n                        g.call(brush);\n\n                        g.selectAll(`#clip-${id} rect`)\n                            .attr('x', 0)\n                            .attr('width', width);\n\n                        g.selectAll('.brush-handle').style('display', 'none');\n                        renderAll();\n                    } else {\n                        const range = filterVal.map(x);\n                        brush.move(gBrush, range);\n                    }\n                }\n\n                g.selectAll('.bar').attr('d', barPath);\n            });\n\n            function barPath(groups) {\n                const path = [];\n                let i = -1;\n                const n = groups.length;\n                let d;\n                while (++i < n) {\n                    d = groups[i];\n                    path.push('M', x(d.key), ',', height, 'V', y(d.value), 'h9V', height);\n                }\n                return path.join('');\n            }\n\n            function resizePath(d) {\n                const e = +(d.type === 'e');\n                const x = e ? 1 : -1;\n                const y = height / 3;\n                return `M${0.5 * x},${y}A6,6 0 0 ${e} ${6.5 * x},${y + 6}V${2 * y - 6}A6,6 0 0 ${e} ${0.5 * x},${2 * y}ZM${2.5 * x},${y + 8}V${2 * y - 8}M${4.5 * x},${y + 8}V${2 * y - 8}`;\n            }\n        }\n\n        brush.on('start.chart', function () {\n            const div = d3.select(this.parentNode.parentNode.parentNode);\n            div.select('.title a').style('display', null);\n        });\n\n        brush.on('brush.chart', function (event) {\n            const g = d3.select(this.parentNode);\n            const brushRange = event.selection || d3.brushSelection(this); // attempt to read brush range\n            const xRange = x && x.range(); // attempt to read range from x scale\n            let activeRange = brushRange || xRange; // default to x range if no brush range available\n\n            const hasRange = activeRange &&\n                activeRange.length === 2 &&\n                !isNaN(activeRange[0]) &&\n                !isNaN(activeRange[1]);\n\n            if (!hasRange) return; // quit early if we don't have a valid range\n\n            // calculate current brush extents using x scale\n            let extents = activeRange.map(x.invert);\n\n            // if rounding fn supplied, then snap to rounded extents\n            // and move brush rect to reflect rounded range bounds if it was set by user interaction\n            if (round) {\n                extents = extents.map(round);\n                activeRange = extents.map(x);\n\n                if (\n                    event.sourceEvent &&\n                    event.sourceEvent.type === 'mousemove'\n                ) {\n                    d3.select(this).call(brush.move, activeRange);\n                }\n            }\n\n            // move brush handles to start and end of range\n            g.selectAll('.brush-handle')\n                .style('display', null)\n                .attr('transform', (d, i) => `translate(${activeRange[i]}, 0)`);\n\n            // resize sliding window to reflect updated range\n            g.select(`#clip-${id} rect`)\n                .attr('x', activeRange[0])\n                .attr('width', activeRange[1] - activeRange[0]);\n\n            // filter the active dimension to the range extents\n            dimension.filterRange(extents);\n\n            // re-render the other charts accordingly\n            renderAll();\n        });\n\n        brush.on('end.chart', function () {\n            // reset corresponding filter if the brush selection was cleared\n            // (e.g. user \"clicked off\" the active range)\n            if (!d3.brushSelection(this)) {\n                reset(id);\n            }\n        });\n\n        chart.margin = function (_) {\n            if (!arguments.length) return margin;\n            margin = _;\n            return chart;\n        };\n\n        chart.x = function (_) {\n            if (!arguments.length) return x;\n            x = _;\n            axis.scale(x);\n            return chart;\n        };\n\n        chart.y = function (_) {\n            if (!arguments.length) return y;\n            y = _;\n            return chart;\n        };\n\n        chart.dimension = function (_) {\n            if (!arguments.length) return dimension;\n            dimension = _;\n            return chart;\n        };\n\n        chart.filter = _ => {\n            if (!_) dimension.filterAll();\n            brushDirty = _;\n            return chart;\n        };\n\n        chart.group = function (_) {\n            if (!arguments.length) return group;\n            group = _;\n            return chart;\n        };\n\n        chart.round = function (_) {\n            if (!arguments.length) return round;\n            round = _;\n            return chart;\n        };\n\n        chart.gBrush = () => gBrush;\n\n        return chart;\n    }\n\n\n\n    function filterBricks(bricks) {\n        data = bricks.filter(brick =>\n            brick && brick.properties && brick.properties.data_portals2019 && brick.properties.data_portals2019._id\n        )\n        return data;\n    };\n\n    function mapBricks(bricks, indicators) {\n        data = bricks.map((brick, index) => {\n            let temp = {};\n            temp['i'] = index;\n            temp['id'] = brick.properties.id;\n            indicators.forEach((indicator) => {\n                temp[indicator.key] = + brick.properties.data_portals2019[indicator.grupo][indicator.key];\n            });\n            return temp;\n        });\n        return data;\n    }\n\n    function buildHtmlContainers(indicators) {\n        let $div = d3.select(\"#charts\")\n            .selectAll(\"div\")\n            .data(indicators)\n            .enter()\n            .append(\"div\")\n            .attr(\"id\", d => d.key)\n            .classed(\"chart\", true)\n            .append(\"div\")\n            .classed(\"title\", true)\n            .text(d => d.screen_name);\n    }\n\n    function buildDimensions(brick, indicators) {\n        let ranges = [];\n        // build the array to store dimensions and groups -ranges-\n        indicators.forEach((indicator) => {\n            let temp =\n            {\n                key: indicator.key,\n                dimension: brick.dimension(d => Math.max(indicator.values.floor, Math.min(indicator.values.ceil, d[indicator.key])))\n                //dimension: brick.dimension(d => Math.min(indicator.values.ceil, d[indicator.key]))\n\n            }\n            // groups of 50 (ranges)\n            temp[\"group\"] = temp.dimension.group(d => Math.floor(d / 10) * 10);\n            ranges.push(temp);\n        });\n        return ranges;\n    }\n\n    function buildCharts(ranges, indicators) {\n        return indicators.map((indicator) => {\n            let range = ranges.filter(d => d.key === indicator.key);\n            return barChart()\n                .dimension(range[0].dimension)\n                .group(range[0].group)\n                .x(d3.scaleLinear()\n                    .domain([indicator.values.floor - 20, indicator.values.ceil + 20])\n                    .rangeRound([0, 10 * 40]));\n        });\n\n    }\n\n\n\n    function drawTotalNumber(brick) {\n        return d3.selectAll('#total')\n            .text(formatNumber(brick.size()));\n    }\n\n    function drawAllValueNumbers() {\n        return d3.select('#active').text(formatNumber(crossAll.value()));\n    }\n\n    // Renders the specified chart or list.\n\n    // Whenever the brush moves, re-rendering everything.\n    function renderAll() {\n        chart.each((method, index, arr) => {\n            render(method, index, arr);\n        });\n        drawAllValueNumbers();\n    }\n    let render = (method, index, arr) => {\n        d3.select(arr[index]).call(method);\n    };\n\n    let filter = filters => {\n        filters.forEach((d, i) => { charts[i].filter(d); });\n        renderAll();\n    };\n\n    let reset = i => {\n        charts[i].filter(null);\n        renderAll();\n    };\n\n\n    function initCrossfilters() {\n        Promise.all([p1, p2, p3])\n            .then(([bricks, activeIndicator, analyticsIndicators]) => {\n                // divs\n                buildHtmlContainers(analyticsIndicators);\n                // filter valid bricks (with data portals)\n                filterBricks(bricks);\n                // build the objects for crossfilter\n                mapBricks(data, analyticsIndicators);\n                // build the array to store dimensions and groups -stored in ranges array-\n                const crossBrick = crossfilter(data);\n                const crossRanges = buildDimensions(crossBrick, analyticsIndicators);\n                charts = buildCharts(crossRanges, analyticsIndicators);\n                // the selection\n                crossAll = crossBrick.groupAll();\n                // the chart selection \n\n                chart = d3.selectAll('.chart').data(charts);\n\n                drawTotalNumber(crossBrick);\n                renderAll();\n\n                let y = data;\n            });\n    };\n\n\n\n    let init = () => {\n        initCrossfilters();\n        return false;\n    };\n\n    init();\n\n\n\n\n})(document, d3);"],"file":"vis.js"}